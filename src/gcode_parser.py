"""
Parser de arquivos G-code do Orca Slicer / BambuStudio
Extrai informações do cabeçalho (comentários)
"""

import re
from pathlib import Path
from dataclasses import dataclass, field
from typing import Optional


@dataclass
class GCodeStatistics:
    """Estatísticas extraídas do G-code"""
    # Tempo
    estimated_time_seconds: int
    estimated_time_str: str
    first_layer_time_seconds: Optional[int] = None
    
    # Filamento total
    total_weight_grams: float = 0.0
    total_length_mm: float = 0.0
    total_volume_cm3: float = 0.0
    total_cost: float = 0.0
    
    # Filamento por slot (1-indexed)
    weight_per_slot: dict[int, float] = field(default_factory=dict)
    length_per_slot: dict[int, float] = field(default_factory=dict)
    cost_per_slot: dict[int, float] = field(default_factory=dict)
    
    # Metadados
    total_layers: int = 0
    max_z_height: float = 0.0
    generator: str = ""
    generation_date: str = ""


class GCodeParser:
    """Parser para extrair informações do cabeçalho de arquivos G-code"""
    
    # Padrões regex para extração
    PATTERNS = {
        'generator': re.compile(r'^; generated by (.+?) on (.+)$'),
        'total_layers': re.compile(r'^; total layer(?:s| number)(?:\s*count)?\s*[=:]\s*(\d+)', re.IGNORECASE),
        'max_z': re.compile(r'^; max_z_height\s*[=:]\s*([\d.]+)'),
        'estimated_time': re.compile(r'^; estimated printing time \(normal mode\)\s*=\s*(.+)$'),
        'first_layer_time': re.compile(r'^; estimated first layer printing time.+?=\s*(.+)$'),
        'total_weight': re.compile(r'^; total filament used \[g\]\s*=\s*([\d.]+)'),
        'total_cost': re.compile(r'^; total filament cost\s*=\s*([\d.]+)'),
        'filament_used_g': re.compile(r'^; filament used \[g\]\s*=\s*(.+)$'),
        'filament_used_mm': re.compile(r'^; filament used \[mm\]\s*=\s*(.+)$'),
        'filament_used_cm3': re.compile(r'^; filament used \[cm3\]\s*=\s*(.+)$'),
        'filament_cost': re.compile(r'^; filament cost\s*=\s*(.+)$'),
    }
    
    def __init__(self, filepath: str | Path):
        self.filepath = Path(filepath)
        if not self.filepath.exists():
            raise FileNotFoundError(f"Arquivo não encontrado: {filepath}")
        if not self.filepath.suffix.lower() == '.gcode':
            raise ValueError(f"Arquivo deve ter extensão .gcode: {filepath}")
    
    def parse(self) -> GCodeStatistics:
        """Extrai estatísticas do cabeçalho e rodapé do G-code"""
        stats = GCodeStatistics(
            estimated_time_seconds=0,
            estimated_time_str=""
        )
        
        # Ler o arquivo em duas partes: início (cabeçalho) e fim (rodapé)
        with open(self.filepath, 'r', encoding='utf-8', errors='ignore') as f:
            # Ler primeiras 2000 linhas (cabeçalho)
            for i, line in enumerate(f):
                if i > 2000:
                    break
                if line.startswith(';'):
                    self._parse_line(line.strip(), stats)
        
        # Ler últimas 500 linhas (rodapé) - onde ficam as estatísticas
        self._parse_footer(stats)
        
        return stats
    
    def _parse_footer(self, stats: GCodeStatistics) -> None:
        """Lê as últimas linhas do arquivo para extrair estatísticas"""
        # Ler todo o arquivo e pegar as últimas linhas
        # Para arquivos grandes, usar seek seria mais eficiente
        try:
            with open(self.filepath, 'rb') as f:
                # Ir para o final e voltar ~50KB
                f.seek(0, 2)  # Fim do arquivo
                file_size = f.tell()
                read_size = min(50000, file_size)  # Últimos 50KB
                f.seek(max(0, file_size - read_size))
                
                content = f.read().decode('utf-8', errors='ignore')
                
            for line in content.split('\n'):
                if line.startswith(';'):
                    self._parse_line(line.strip(), stats)
        except Exception:
            pass  # Ignorar erros na leitura do rodapé
    
    def _parse_line(self, line: str, stats: GCodeStatistics) -> None:
        """Processa uma linha e extrai informações"""
        
        # Generator e data
        match = self.PATTERNS['generator'].match(line)
        if match:
            stats.generator = match.group(1)
            stats.generation_date = match.group(2)
            return
        
        # Total de camadas
        match = self.PATTERNS['total_layers'].match(line)
        if match:
            stats.total_layers = int(match.group(1))
            return
        
        # Altura máxima Z
        match = self.PATTERNS['max_z'].match(line)
        if match:
            stats.max_z_height = float(match.group(1))
            return
        
        # Tempo estimado
        match = self.PATTERNS['estimated_time'].match(line)
        if match:
            stats.estimated_time_str = match.group(1).strip()
            stats.estimated_time_seconds = self._parse_time(stats.estimated_time_str)
            return
        
        # Tempo primeira camada
        match = self.PATTERNS['first_layer_time'].match(line)
        if match:
            stats.first_layer_time_seconds = self._parse_time(match.group(1).strip())
            return
        
        # Peso total
        match = self.PATTERNS['total_weight'].match(line)
        if match:
            stats.total_weight_grams = float(match.group(1))
            return
        
        # Custo total
        match = self.PATTERNS['total_cost'].match(line)
        if match:
            stats.total_cost = float(match.group(1))
            return
        
        # Filamento usado por slot [g]
        match = self.PATTERNS['filament_used_g'].match(line)
        if match:
            values = self._parse_csv_values(match.group(1))
            stats.weight_per_slot = {i+1: v for i, v in enumerate(values) if v > 0}
            return
        
        # Filamento usado por slot [mm]
        match = self.PATTERNS['filament_used_mm'].match(line)
        if match:
            values = self._parse_csv_values(match.group(1))
            stats.length_per_slot = {i+1: v for i, v in enumerate(values) if v > 0}
            stats.total_length_mm = sum(values)
            return
        
        # Filamento usado por slot [cm3]
        match = self.PATTERNS['filament_used_cm3'].match(line)
        if match:
            values = self._parse_csv_values(match.group(1))
            stats.total_volume_cm3 = sum(values)
            return
        
        # Custo por slot
        match = self.PATTERNS['filament_cost'].match(line)
        if match:
            values = self._parse_csv_values(match.group(1))
            stats.cost_per_slot = {i+1: v for i, v in enumerate(values) if v > 0}
            return
    
    @staticmethod
    def _parse_time(time_str: str) -> int:
        """Converte string de tempo para segundos (ex: '2h 6m 5s' -> 7565)"""
        total_seconds = 0
        
        hours = re.search(r'(\d+)\s*h', time_str)
        minutes = re.search(r'(\d+)\s*m', time_str)
        seconds = re.search(r'(\d+)\s*s', time_str)
        
        if hours:
            total_seconds += int(hours.group(1)) * 3600
        if minutes:
            total_seconds += int(minutes.group(1)) * 60
        if seconds:
            total_seconds += int(seconds.group(1))
        
        return total_seconds
    
    @staticmethod
    def _parse_csv_values(csv_str: str) -> list[float]:
        """Converte string CSV para lista de floats"""
        values = []
        for part in csv_str.split(','):
            part = part.strip()
            try:
                values.append(float(part))
            except ValueError:
                values.append(0.0)
        return values
